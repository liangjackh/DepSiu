| ID | Assertion | Bug Number | Bug Description | Module | CWE-ID | FPV Verification Results |
|----| ---- | ---- | ---- | ---- | ---- | ---- |
|p1|assert -name HACKDAC\_p1 {((\`SOC\_CTRL\_END\_ADDR <= \`UDMA\_START\_ADDR) && (\`SOC\_CTRL\_START\_ADDR >= \`UDMA\_END\_ADDR))}|1|Address range overlap between peripherals SPI Master and SoC.|periph_bus_defines|CWE-1260 or CWE-1203|Violation found|
|p2|assert -name HACKDAC\_p2 {(\~((soc\_interconnect.TCDM\_data\_gnt\_DEM\_TO\_XBAR) >> 1) && ((soc\_interconnect.TCDM\_data\_add\_DEM\_TO\_XBAR >= 32'h1C00\_0000) && (soc\_interconnect.TCDM\_data\_add\_DEM\_TO\_XBAR <= 32'h1C08\_0000)))} |2|Addresses for L2 memory is out of the specified range.|soc_interconnect|CWE-1203|Violation found|
|p3|assert -name HACKDAC\_p3 {(\~((riscv\_core.cs\_registers\_i.priv\_lvl\_n == riscv\_core.cs\_registers\_i.PRIV\_LVL\_M) && riscv\_core.cs\_registers\_i.mstatus\_n.mpp ==riscv\_core.cs\_registers\_i.PRIV\_LVL\_U))}|3|Processor assigns privilege level of execution incorrectly from CSR.|riscv_cs_registers|CWE-1207|Violation found|
|p4|assert -name HACKDAC\_p4 {\~((apb\_gpio.PWDATA == 32'h1234\_5678) && ((apb\_gpio.s\_apb\_addr ==5'b10010) && (apb\_gpio.r\_gpio\_lock==32'h1234\_5678)))} |4|Register that controls GPIO lock can be written to with software.|apb_gpio|CWE-1207|Violation found|
|p5|cover -name HACKDAC\_p5 {\~((apb\_gpio.HRESETn) \|\| (apb\_gpio.r\_gpio\_lock ==0))}|5|Reset clears the GPIO lock control register.|apb_gpio|CWE-1206|Violation found|
|p6|assert -name HACKDAC\_p6 {(\`GPIO\_START\_ADDR == 32'h1A10\_1000) && (\`GPIO\_END\_ADDR == 32'h1A10\_1FFF)}|6|Incorrect address range for APB allows memory aliasing.|periph_bus_defines|CWE-1257|Violation found|
|p7|assert -name HACKDAC\_p7 {((axi\_address\_decoder\_AR.outstanding\_trans\_i) && (axi\_address\_decoder\_AR.CS == axi\_address\_decoder\_AR.NS))}|7|AXI address decoder ignores errors.|axi_address_decoder_AR|CWE-20|Violation found|
|p8|assert -name HACKDAC\_p8 {(((\`GPIO\_END\_ADDR <= \`UDMA\_START\_ADDR) && (\`GPIO\_START\_ADDR >= \`UDMA\_END\_ADDR)) && ((\`SOC\_CTRL\_END\_ADDR <= \`UDMA\_START\_ADDR) && (\`SOC\_CTRL\_START\_ADDR >= \`UDMA\_END\_ADDR)) && ((\`SOC\_CTRL\_END\_ADDR <= \`GPIO\_START\_ADDR) && (\`SOC\_CTRL\_START\_ADDR >= \`GPIO\_END\_ADDR)))}|8|Address range overlap between GPIO, SPI, and SoC control peripherals.|periph_bus_defines|CWE-1260 or CWE-1203|Violation found|
|p9|assert -name HACKDAC\_p9 {\~((adbg\_tap\_top.passchk==1) && \~(adbg\_tap\_top.bitindex==32))} |9|Incorrect password checking logic in debug unit.|adbg_tap_top|CWE-1221|Violation found|
|p10|assert -name HACKDAC\_p10 {(adbg\_tap\_top.passchk == 1) \|-> (adbg\_tap\_top .bitindex == 32)}|10|Advanced debug unit only checks 31 of the 32 bits of the password.|adbg_tap_top|CWE-1298|Violation found|
|p11|assert -name HACKDAC\_p11 {(\~( (riscv\_core.debug\_unit\_i.dbg\_halt != 1) && (riscv\_core.debug\_unit\_i.rdata\_sel\_n == riscv\_core.RD\_DBGS)))} |11|Able to access debug register when in halt mode.|riscv_core|CWE-1298|Violation found|
|p12|assert -name HACKDAC\_p12 {(\~(adbg\_tap\_top.passchk ==1) && (adbg\_tap\_top.correct <= 31))}|12|Password check for the debug unit does not reset after successful check.|adbg_tap_top|1329|Violation found|
|p13|assert -name HACKDAC\_p13 {(riscv\_core.id\_stage\_i.controller\_i.ctrl\_fsm\_ns == riscv\_core.id\_stage\_i.controller\_i.DECODE) \|=> (riscv\_core.id\_stage\_i.controller\_i.ctrl\_fsm\_ns != riscv\_core.id\_stage\_i.controller\_i.DECODE)}|13|Faulty decoder state machine logic in RISC-V core results in a hang.|riscv_core|CWE-1245|Violation found|
|p14|assert -name HACKDAC\_p14 {((( (riscv\_core.ex\_stage\_i.alu\_i.vector\_mode\_i == riscv\_core.ex\_stage\_i.alu\_i.VEC\_MODE16) \|\| (riscv\_core.ex\_stage\_i.alu\_i.vector\_mode\_i == riscv\_core.ex\_stage\_i.alu\_i.VEC\_MODE8) ) \|-> riscv\_core.ex\_stage\_i.alu\_i.adder\_in\_a[18] == 1'b0) )}|14|Incomplete case statement in ALU can cause unpredictable behavior.|riscv_core|CWE-1245|Violation found|
|p15|assert -name HACKDAC\_p15 {(rtc\_clock.r\_seconds < 8â€™h59)}|15|Faulty logic in the RTC causing inaccurate time calculation for security-critical flows, e.g., DRM.|rtc_clock|CWE-1247|Violation found|
|p16|assert -name HACKDAC\_p16 {(adbg\_tap\_top.trstn\_pad\_i) \|\| (adbg\_tap\_top.correct==0)}|16|Reset for the advanced debug unit not operational.|adbg_tap_top|CWE-1419|Violation found|
|p17|assert -name HACKDAC\_p21 {(\~(mux\_func.c == mux\_func.temperature\_out))}|21|Temperature sensor is muxed with the cryptography modules.|mux_func|1240|Violation found|
|p18|assert -name HACKDAC\_p27 {riscv\_core.cs\_registers\_i.csr\_we\_int \|-> riscv\_core.cs\_registers\_i.PULP\_SECURE}|27|Secure mode is not required to write to interrupt registers.|riscv_core|1220|Violation found|
|p19|assert -name HACKDAC\_p28 {((jtag\_tap\_top.td\_i == 1 \|\| jtag\_tap\_top.td\_i == 0))}|28|JTAG interface is not password protected.|jtag_tap_top|1262|No violations found|
|p20|assert -name HACKDAC\_p29 {rst \|-> aes\_out == 0 && c == 0}|29|Output of MAC is not erased on reset.|mux_func|325|Violation found|
